---
title: RKYOLO诞生记 (前传)：一切开始之前——那三个小时的“系统急救
tags:
  - Rust
  - YOLO
  - AI
  - 嵌入式
  - 系统编程
  - 开源
categories:
  - - 技术实践
  - - 人工智能
  - - 计算机视觉
  - - 边缘计算部署
  - - RKYOLO诞生记
date: 2025-09-10 07:31:36
---

读到这里，你已经陪我走完了 `rkyolo` 从一个想法到一个功能完备的框架的全过程。但在这个故事开始之前，还有一段小插曲。它虽然只占了大概三个小时，却为后面所有的“顺利”铺平了道路，也算是一场有惊无险的“系统急救”演练。

<!-- more -->

#### **起因：一个不得不升的“驱动版本”**

事情起因很简单：我开发板上的 RKNPU 驱动版本（`0.9.7`）太旧了，跑不了新模型。想接着玩，就得升级驱动。在嵌入式 Linux 上，这通常意味着一件事：**得重新编译内核**。

#### **过程：从编译到“系统懵了”**

对于搞过嵌入式的人来说，交叉编译内核算是个常规操作，无非是配置多、耗时长。我搭好环境，找来内核源码，第一个小麻烦就来了：

开发板上跑的内核版本是 `6.1.0`，但我在官方源码的标签里翻来翻去就是找不到完全一样的。最后靠着一行 `git tag -l` 进行地毯式搜索，才揪出了那个被“伪装”起来的特定版本——**`Ubuntu-rockchip-6.1.0-1025.25`**。算是明白了系统版的第一个小“花招”：表面版本号背后可能另有文章。

费了点功夫编译出内核产物后，真正的麻烦在部署时来了。一条看似平常的 `sudo tar -xzvf ... -C /` 指令，不知怎的，把我系统里 `/lib` 这个关键的符号链接给冲掉了。

一瞬间，系统就“懵了”。

所有依赖动态链接库的命令，像 `sudo`、`ls`、`mv`，全都报 `command not found`。系统没了最基础的“自理能力”，成了一块砖。

#### **救援：三小时“手动修砖”**

常用的救援方法这时候都指望不上了。情况有点棘手，但还能救：

1.  **UMS 模式，“挂盘”修理**：我用串口让开发板进入 UMS（USB Mass Storage）模式，然后在 Arch 主机上直接挂载了 eMMC 的分区。像做手术一样，我删掉了错误的 `/lib`，重新建好了正确的符号链接。

2.  **重启，遇上新问题**：系统总算活过来了，新内核也成功启动，NPU 驱动版本也更新了！可新的怪事又来了：有线网卡没了，`lsmod` 显示一片空白——内核模块全都没加载上。

3.  **最后一步，“物归原处”**：我愣了一下，突然想起之前救急时动过不少东西。敲了 `uname -a`，显示内核版本是 **`6.1.75+`**，但去 `find /lib/modules/` 里找，压根没这目录！我马上反应过来，估计是之前手忙脚乱，把放内核模块的整个目录给挪歪了。再次进 UMS 模式一查，果然如此。

**一行 `mv` 命令，物归原处。**

**一次重启。**

**网络回来了，GPU 驱动正常了，所有模块都加载成功了。**

**好了，YOLO 程序终于可以跑起来了。**

#### **所以，为什么是 RKYOLO？**

这紧张兮兮的三个小时，虽然没多久，却是我最后决定从头写 `rkyolo` 的真正原因。

正因为亲手经历了一次因为一个不小心就把整个系统搞崩的事，我才格外明白，在底层搞开发，**代码的健壮性和行为的可预测性**有多重要。

这也让我彻底想清楚了：

我需要的不是一个脆弱的、满是硬编码、构建复杂的 C++ 示例。我需要一个**从设计之初就把安全和可靠放在首位的系统**。

所以，我选择了 **Rust**，我决定自己搞一个 **RKYOLO**。

这个小插曲，就是 RKYOLO 之所以开始的理由。它不只是一个项目，更像是我对“怎么才能写好嵌入式软件”这个问题，交上的一份自己的答卷。
